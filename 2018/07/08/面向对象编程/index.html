<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"xuquan.site","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="面向对象编程是JS里一个非常核心的思想，几乎所有面试的习题也都会涉及到这部分内容。这次FCC改版后的习题也单独把这部分内容做成了一个模块。以线性的创建父类和子类的顺序来讲解知识点。">
<meta property="og:type" content="article">
<meta property="og:title" content="面向对象编程">
<meta property="og:url" content="https://xuquan.site/2018/07/08/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Nikkkki&#39;s Notes">
<meta property="og:description" content="面向对象编程是JS里一个非常核心的思想，几乎所有面试的习题也都会涉及到这部分内容。这次FCC改版后的习题也单独把这部分内容做成了一个模块。以线性的创建父类和子类的顺序来讲解知识点。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/9240001-3b087188be2960ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/9240001-9435ecc6f74e0484.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/9240001-613e502f569c5588.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/9240001-ff8d9dd7746b7f45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/9240001-235ed6c0cf602e21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="article:published_time" content="2018-07-07T16:38:36.000Z">
<meta property="article:modified_time" content="2018-08-08T09:45:40.000Z">
<meta property="article:author" content="Xu Quan">
<meta property="article:tag" content="freecodecamp">
<meta property="article:tag" content="OOP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/9240001-3b087188be2960ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">


<link rel="canonical" href="https://xuquan.site/2018/07/08/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://xuquan.site/2018/07/08/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/","path":"2018/07/08/面向对象编程/","title":"面向对象编程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>面向对象编程 | Nikkkki's Notes</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Nikkkki's Notes</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E6%98%AF%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.</span> <span class="nav-text">1. 第一个核心概念是对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%AC%AC%E4%BA%8C%E4%B8%AA%E7%9F%A5%E8%AF%86%E7%82%B9%E6%98%AF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0constructor"><span class="nav-number">2.</span> <span class="nav-text">2. 第二个知识点是构造函数constructor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">2.1.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.2.</span> <span class="nav-text">函数对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.3.</span> <span class="nav-text">本地对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.4.</span> <span class="nav-text">内置对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E7%94%A8instanceof%E6%9D%A5%E5%88%A4%E6%96%AD%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="nav-number">3.</span> <span class="nav-text">3. 用instanceof来判断构造函数的实例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#typeof%E7%94%A8%E4%BA%8E%E5%88%A4%E6%96%AD%E5%8F%98%E9%87%8F%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.1.</span> <span class="nav-text">typeof用于判断变量的类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2%E6%96%B9%E6%A1%88"><span class="nav-number">3.1.1.</span> <span class="nav-text">替换方案</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#instanceof%E7%94%A8%E4%BA%8E%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B7%E4%BD%93%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.2.</span> <span class="nav-text">instanceof用于判断对象的具体类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#instanceof%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">3.2.1.</span> <span class="nav-text">instanceof实现原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%87%AA%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E5%8E%9F%E5%9E%8B%E5%B1%9E%E6%80%A7"><span class="nav-number">4.</span> <span class="nav-text">4. 对象的自有属性和原型属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%AE%9E%E4%BE%8B%E7%9A%84-constructor-%E5%B1%9E%E6%80%A7"><span class="nav-number">5.</span> <span class="nav-text">5. 实例的**constructor**属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E4%BF%AE%E6%94%B9%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="nav-number">6.</span> <span class="nav-text">6. 修改构造函数原型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="nav-number">7.</span> <span class="nav-text">7. 原型和原型链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-Object-create%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B"><span class="nav-number">8.</span> <span class="nav-text">8. Object.create创建实例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#new-%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">8.1.</span> <span class="nav-text">new()创建实例实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-create-%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">8.2.</span> <span class="nav-text">Object.create()创建实例实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DRY%E5%8E%9F%E5%88%99"><span class="nav-number">8.3.</span> <span class="nav-text">DRY原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">8.4.</span> <span class="nav-text">继承父类的属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">8.5.</span> <span class="nav-text">自己的方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7"><span class="nav-number">9.</span> <span class="nav-text">10. 私有属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0"><span class="nav-number">10.</span> <span class="nav-text">11. 立即执行函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%A0%E9%A2%98Introduction-to-the-Object-Oriented-Programming-Challenges"><span class="nav-number">10.1.</span> <span class="nav-text">习题Introduction to the Object Oriented Programming Challenges</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Xu Quan</p>
  <div class="site-description" itemprop="description">一个程序员的自我进修之路</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">197</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">112</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/XuQuan-nikkkki" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;XuQuan-nikkkki" rel="noopener me" target="_blank"><i class="fa-brands fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:xuquan1225@gmail.com" title="E-Mail → mailto:xuquan1225@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.douban.com/people/nikkkki/?_i=8570912tq6k9lM" title="Douban → https:&#x2F;&#x2F;www.douban.com&#x2F;people&#x2F;nikkkki&#x2F;?_i&#x3D;8570912tq6k9lM" rel="noopener me" target="_blank"><i class="豆 fa-fw"></i>Douban</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xuquan.site/2018/07/08/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xu Quan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nikkkki's Notes">
      <meta itemprop="description" content="一个程序员的自我进修之路">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="面向对象编程 | Nikkkki's Notes">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面向对象编程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-07-08 00:38:36" itemprop="dateCreated datePublished" datetime="2018-07-08T00:38:36+08:00">2018-07-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2018-08-08 17:45:40" itemprop="dateModified" datetime="2018-08-08T17:45:40+08:00">2018-08-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/FreeCodeCamp/" itemprop="url" rel="index"><span itemprop="name">FreeCodeCamp</span></a>
        </span>
    </span>

  
    <span id="/2018/07/08/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" class="post-meta-item leancloud_visitors" data-flag-title="面向对象编程" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2018/07/08/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/07/08/面向对象编程/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p><strong>面向对象编程</strong>是JS里一个非常核心的思想，几乎所有面试的习题也都会涉及到这部分内容。这次FCC改版后的习题也单独把这部分内容做成了一个模块。以线性的创建父类和子类的顺序来讲解知识点。</p>
<span id="more"></span>

<hr>
<h3 id="1-第一个核心概念是对象"><a href="#1-第一个核心概念是对象" class="headerlink" title="1. 第一个核心概念是对象"></a>1. 第一个核心概念是<strong>对象</strong></h3><p>在JavaScript中，万物皆对象。所谓对象，就是<strong>一种特殊的数据类型</strong>，拥有<strong>属性</strong>和<strong>方法</strong>。</p>
<ul>
<li>第1题：创建JS对象，给对象添加属性</li>
<li>第2题：通过<code>obj.property</code>获取对象的属性值</li>
<li>第3题：为属性添加方法</li>
<li>第4题：在属性的方法中使用<code>this</code>关键字指代对象本身</li>
</ul>
<hr>
<h3 id="2-第二个知识点是构造函数constructor"><a href="#2-第二个知识点是构造函数constructor" class="headerlink" title="2. 第二个知识点是构造函数constructor"></a>2. 第二个知识点是<strong>构造函数</strong><code>constructor</code></h3><p>构造函数用来创建对象，它的属性、方法都定义在函数内。</p>
<p>第5题：规范的构造函数写法（函数名首字母大写，<code>this</code>指代对象、用于定义对象）</p>
<p>第6题：<code>new</code>关键字创建构造函数的实例对象</p>
<p>第7题：构造函数可以接受参数</p>
<blockquote>
<p>这里需要搞清楚几个概念的区别：</p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;...&#125;</span><br><span class="line">&gt;<span class="keyword">var</span> foo = <span class="keyword">function</span>(<span class="params"></span>) &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>前者是<strong>函数声明</strong>，后者是<strong>函数表达式</strong>。两种写法的<code>typeof foo</code>结果都是<code>function</code></p>
<h4 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h4><p>函数就是对象，代表函数的对象就是函数对象。在JavaScript的定义中，<strong>每一个函数实际上都是一个函数对象</strong>，JS代码中定义函数或者调用<code>Function</code>创建函数时，最终都以类似这样的形式调用<code>Function</code>函数： <code>var newFunc = new Function(funcArgs, funcBody)</code>。</p>
<p>因此，在语法上，函数都称为函数对象。从用法上，如果我们单纯把它作为函数使用，那么它就是函数；<strong>如果我们通过它来实例化出对象来使用，那么它就可以当成一个函数对象来使用</strong>。在面向对象的范畴里面，函数对象类似于<strong>类</strong>的概念。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;...&#125;</span><br><span class="line">&gt;<span class="keyword">typeof</span> foo <span class="comment">//object</span></span><br><span class="line">                         </span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;...&#125;</span><br><span class="line">&gt;<span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line">&gt;<span class="keyword">typeof</span> foo  <span class="comment">//object</span></span><br></pre></td></tr></table></figure>



<p>弄清楚函数和对象的概念能让我们更好地理解<code>__proto__</code>和<code>prototype</code></p>
<p>还有两个对象的概念也需要我们了解：</p>
<h4 id="本地对象"><a href="#本地对象" class="headerlink" title="本地对象"></a>本地对象</h4><p>本都对象（native object）被定义为<strong>独立于宿主环境的ECMAScript实现提供的对象</strong>，简单来说，就是ECMA-262定义的<strong>类（引用类型）</strong>，包括<code>Object, Function, Array, String, Boolean, Number, Date, RegExp, Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">typeof</span>(<span class="title class_">Object</span>);</span><br><span class="line">&gt;<span class="title function_">typeof</span>(<span class="title class_">Array</span>);</span><br><span class="line">&gt;<span class="title function_">typeof</span>(<span class="title class_">String</span>);</span><br><span class="line">&gt;...</span><br></pre></td></tr></table></figure>

<p>以上返回结果都是<code>function</code>，即以上本地对象都是通过<code>function</code>建立起来的（比较容易理解的方法是这些对象在创建的过程中，都是可以通过类似<code>let str = new String()</code>这样的方法来创建的）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">Object</span>(<span class="params"></span>) &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出<code>Object</code>原本就是一个函数，通过<code>new Object()</code>实例化后创建对象。</p>
<h4 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h4><p>内置对象(built-in object)即<strong>由ECMAScript实现提供的、独立于宿主环境的所有对象，在ECMAScript程序开始执行时出现</strong>，这意味着不必明确实例化内置对象，它们已经被实例化了。</p>
<p>内置对象有两个，即<code>Global</code>和<code>Math</code>，此外，它们也是本地对象，<strong>每个内置对象都是本地对象</strong></p>
</blockquote>
<hr>
<h3 id="3-用instanceof来判断构造函数的实例"><a href="#3-用instanceof来判断构造函数的实例" class="headerlink" title="3. 用instanceof来判断构造函数的实例"></a>3. 用<code>instanceof</code>来判断构造函数的实例</h3><p>使用方法是:<code>实例 instanceof 构造函数</code>，结果会返回一个布尔值。</p>
<blockquote>
<p>一般有两个常用的判断类型的方法：<code>typeof</code>和<code>instanceof</code></p>
<h4 id="typeof用于判断变量的类型"><a href="#typeof用于判断变量的类型" class="headerlink" title="typeof用于判断变量的类型"></a><code>typeof</code>用于判断<em>变量</em>的类型</h4><p>我们可以用<code>typeof</code>来判断<code>number, string, object, boolean, function, undefined, symbol</code>这七种类型。</p>
<p><strong>缺陷：</strong></p>
<p>在判断不是<code>object</code>类型的数据的时候，<code>typeof</code>能够清楚地告诉我们具体是哪一类的数据，</p>
<p>但是在判断<code>object</code>数据时，只能告诉我们这个数据是<code>object</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> str2 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">typeof</span> str1;   <span class="comment">//string</span></span><br><span class="line"><span class="keyword">typeof</span> str2;   <span class="comment">//object</span></span><br></pre></td></tr></table></figure>

<p>需要判断数据是具体哪一种<code>object</code>的时候，我们需要利用<code>instanceof</code>这个操作符。</p>
<p><strong><code>typeof</code>的实现原理</strong></p>
<p>JavaScript在底层存储变量时，不同对象在底层都表现为二进制，且<strong>会在变量的机器码的低位1-3位存储其类型信息</strong>，如：</p>
<ul>
<li>000： 对象</li>
<li>010： 浮点数</li>
<li>100： 字符串</li>
<li>110： 布尔值</li>
<li>1：     整数</li>
</ul>
<p>根据JS判断类型的代码，<code>typeof</code>会</p>
<ul>
<li>先判断是否为<code>undefined</code></li>
<li>如果不是<code>undefined</code>，判断是否为对象</li>
<li>如果不是对象，判断是否为数字</li>
<li>…</li>
</ul>
<p>所以这里有一个bug，<code>null</code>的所有机器码均为0，如果用<code>typeof</code>来判断，会被判断为<code>object</code>。但用<code>instanceof</code>来判断又会出现矛盾的结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>;            <span class="comment">//&quot;object&quot;</span></span><br><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>  <span class="comment">//false</span></span><br><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> <span class="literal">null</span>    <span class="comment">//TypeError: Right-hand side of &#x27;instanceof&#x27; is not an object</span></span><br></pre></td></tr></table></figure>

<p>所以在使用<code>typeof</code>判断变量的时候，要注意，尽量使用<code>typeof</code>来判断基础数据类型，避免对<code>null</code>的判断。</p>
<h5 id="替换方案"><a href="#替换方案" class="headerlink" title="替换方案"></a>替换方案</h5><p>我们可以利用<code>Object.prototype.toString.call()</code>方法来实现对变量类型的比较准确的判断</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">1</span>)            <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&#x27;hi&#x27;</span>)         <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123;<span class="attr">a</span>:<span class="string">&#x27;hi&#x27;</span>&#125;)     <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>])      <span class="comment">// &quot;[object Array]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">true</span>)         <span class="comment">// &quot;[object Boolean]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="function">()=&gt;</span>&#123;&#125;)       <span class="comment">// &quot;[object Function]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>)         <span class="comment">// &quot;[object Null]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">undefined</span>)    <span class="comment">// &quot;[object Undefined]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="title class_">Symbol</span>(<span class="number">1</span>))    <span class="comment">// &quot;[object Symbol]&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="instanceof用于判断对象的具体类型"><a href="#instanceof用于判断对象的具体类型" class="headerlink" title="instanceof用于判断对象的具体类型"></a><code>instanceof</code>用于判断<em>对象</em>的具体类型</h4><p><code>instanceof</code>主要用于<strong>判断一个实例是否属于某个类型</strong>。如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Person</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ps1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">ps1 <span class="keyword">instanceof</span> <span class="title class_">Person</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><code>instanceof</code>也可以判断一个实例是否是其父类或者祖父类的实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Person</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Programmer</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Programmer</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">let</span> ps1 = <span class="keyword">new</span> <span class="title class_">Programmer</span>();</span><br><span class="line">ps1 <span class="keyword">instanceof</span> <span class="title class_">Person</span> <span class="comment">//true</span></span><br><span class="line">ps1 <span class="keyword">instanceof</span> <span class="title class_">Programmer</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure>



<h5 id="instanceof实现原理"><a href="#instanceof实现原理" class="headerlink" title="instanceof实现原理"></a><code>instanceof</code>实现原理</h5><p>这里引用<a target="_blank" rel="noopener" href="https://tinycat2017.github.io/2018/05/28/%E6%B5%85%E8%B0%88-instanceof-%E5%92%8C-typeof-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">浅谈 instanceof 和 typeof 的实现原理</a>里的一段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">new_instance_of</span>(<span class="params">leftVaule, rightVaule</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> rightProto = rightVaule.<span class="property"><span class="keyword">prototype</span></span>;<span class="comment">// 取右表达式的 prototype 值</span></span><br><span class="line">    leftVaule = leftVaule.<span class="property">__proto__</span>;<span class="comment">// 取左表达式的__proto__值</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(leftVaule ===<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(leftVaule === rightProto)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        leftVaule = leftVaule.<span class="property">__proto__</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>instanceof</code>的实现原理就是<strong>只要右边变量的<code>prototype</code>在左边变量的原型链上即可</strong>,上面这段代码会遍历左边变量的原型链，直到找到右边变量的<code>prototype</code>，如果没有找到，则返回<code>false</code>.</p>
<p>具体原型链如何实现继承，我们在后面会讲到。</p>
</blockquote>
<hr>
<h3 id="4-对象的自有属性和原型属性"><a href="#4-对象的自有属性和原型属性" class="headerlink" title="4. 对象的自有属性和原型属性"></a>4. 对象的<strong>自有属性</strong>和<strong>原型属性</strong></h3><ul>
<li>构造函数中定义的属性叫做<strong>自有属性</strong>，自有属性直接被定义给实例，即实例各自拥有这些属性的副本</li>
<li>添加在原型<code>prototype</code>上的属性叫做<strong>原型属性</strong>，原型是实例共有的对象，添加在原型上的属性也能通过实例获取到</li>
</ul>
<p>通过**<code>for(let property in object)</code><strong>可以遍历对象的属性，通过</strong><code>hasOwnProperty(property)</code>**方法可用区分自有属性和原型属性</p>
<hr>
<h3 id="5-实例的-constructor-属性"><a href="#5-实例的-constructor-属性" class="headerlink" title="5. 实例的**constructor**属性"></a>5. 实例的**<code>constructor</code>**属性</h3><p>实例都拥有一个特殊的属性<code>constructor</code>，指向创建这个实例的构造函数。</p>
<p>但是实例的<code>constructor</code>属性可以被改写，所以<code>object.constructor</code>来获得的结果不一定是<code>object</code>的构造函数，需要验证实例的构造函数时，还是使用<code>instanceof</code></p>
<hr>
<h3 id="6-修改构造函数原型"><a href="#6-修改构造函数原型" class="headerlink" title="6. 修改构造函数原型"></a>6. 修改构造函数原型</h3><p>当需要添加的原型属性太多时，我们可以直接<strong>给构造函数指定新的原型</strong>，在新的原型的对象中添加需要给原型的属性和方法。</p>
<p>需要注意的是，这个过程中<strong>会抹去构造函数的<code>constructor</code>属性</strong>，所以需要我们手动地添加定义<code>constructor</code>的语句（可以在新的<code>prototype</code>对象中定义）</p>
<hr>
<h3 id="7-原型和原型链"><a href="#7-原型和原型链" class="headerlink" title="7. 原型和原型链"></a>7. <strong>原型和原型链</strong></h3><p>原型和原型链是面向对象编程部分的重点和难点。</p>
<p><strong>首先需要辨析两个关于原型概念：</strong></p>
<ul>
<li><p><strong><code>prototype</code>属性</strong>：前面原型属性部分就提到了<code>prototype</code>，**<code>prototype</code>是每个函数都有的属性**，但不是每个对象都有的属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;...&#125;  <span class="comment">//Foo.prototype: Foo &#123;&#125;</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="title class_">Foo</span>()   <span class="comment">//foo.prototype: undefined, foo.__proto__: Foo &#123;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>__proto__</code><strong>：</strong><code>__proto__</code>是每个函数和对象都隐含的一个属性</strong>，它指向创建它的构造函数的<code>prototype</code>,即**<code>Supertype.prototype === subtype.__proto__</code>**。</p>
</li>
</ul>
<p><strong>其次，我们需要知道为什么存在<code>prototype</code>属性</strong></p>
<p>JavaScript里所有的数据类型都是对象，为了实现面向对象的思想，就必须实现<strong>继承</strong>来把所有的对象都连接起来。JavaScript是通过<code>new</code>来创建实例的，比如我们创建两个实例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Mother</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">father</span> = <span class="string">&quot;father&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child1 = <span class="keyword">new</span> <span class="title class_">Mother</span>(<span class="string">&#x27;c1&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> child2 = <span class="keyword">new</span> <span class="title class_">Mother</span>(<span class="string">&quot;c2&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这时发现其实<code>child2</code>的父亲并不是<code>father</code>，而是<code>Father</code>，我们修改<code>child2</code>的<code>father</code>属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">child2.<span class="property">father</span> = <span class="string">&quot;Father&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="property">father</span>);   <span class="comment">//father</span></span><br></pre></td></tr></table></figure>

<p>当我们修改了<code>child2</code>的<code>father</code>属性之后，<code>child1</code>的<code>father</code>属性并没有改变，因为属性的值无法共享。</p>
<p>而<code>prototype</code>属性所起的作用就是<strong>把需要共享的属性都放到构造函数的<code>prototype</code>上，这样每一个实例都能够获取到这些属性</strong>。</p>
<p><strong>接着需要知道构造函数和实例原型之间的关系：</strong></p>
<p>上面提到，每个函数都有<code>prototype</code>属性，每个对象（<code>null</code>除外）在创建的时候就会有一个与之关联的对象，这个对象就是我们说的原型，每一个对象都会从原型“继承”属性。</p>
<p> <img src="https://upload-images.jianshu.io/upload_images/9240001-3b087188be2960ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="构造函数的prototype属性"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;nikkkki&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>);   <span class="comment">//nikkkki</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="property">name</span>);   <span class="comment">//nikkkki</span></span><br></pre></td></tr></table></figure>
<p> <code>Person</code>作为构造函数，在创建<code>person1</code>和<code>person2</code>的时候，这两个实例都会与<code>Person</code>的<code>prototype</code>属性关联，并从它继承属性，<code>Person.prototype.name</code>给<code>prototype</code>属性添加了<code>name</code>值，于是两个实例都能够获取到这个值。</p>
<p> 所有的对象都是<code>Object</code>衍生出来的，因此所有的对象原型链终点都是<code>Object.prototype</code>的实例。</p>
<p> 每个JavaScript对象(除了<code>null</code>)还有<code>__proto__</code>属性，它指向该对象的原型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> === person.<span class="property">__proto__</span>);   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p> 所以构造函数在构建实例时，除了有实例原型<code>prototype</code>，还让实例的原型<code>__proto__</code>指向了实力原型。</p>
<p> <img src="https://upload-images.jianshu.io/upload_images/9240001-9435ecc6f74e0484.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="__proto__"></p>
<p> 前面<code>5</code>提到每个实例都有<code>constructor</code>属性，并且该属性指向这个实例的构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>);   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p> 所以我们在这里加上<code>constructor</code>属性与<code>prototype</code>属性对应。</p>
<p> <img src="https://upload-images.jianshu.io/upload_images/9240001-613e502f569c5588.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="constructor"></p>
<p> 这里我们记住<strong>原型的3大定律</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">__proto__</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>)  <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Person</span>)   <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(person) === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>)  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p> <strong>那么原型链是什么呢？</strong></p>
<p> 所有对象的原型<code>__proto__</code>都指向构造函数的<code>prototype</code>属性，而所有的构造函数都是函数对象，所有的对象都是<code>Object</code>衍生出来的，也就是说所有的实例向上追溯<code>__proto__</code>，最终都会到达<code>Object.prototype</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>);  <span class="comment">//undefined</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;nikkkki&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>);  <span class="comment">//nikkkki</span></span><br></pre></td></tr></table></figure>

<p> 我们可以将<code>Object</code>加入到关系图中：<br> <img src="https://upload-images.jianshu.io/upload_images/9240001-ff8d9dd7746b7f45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Object作为源头"></p>
<p> 当查找实例的属性时，会现在实例本身查找，如果实例没有这个属性，就会在实例的构造函数的<code>prototype</code>上查找，一直到<code>Object.prototype</code>。</p>
<p>**<code>Object.prototype</code>的原型是<code>null</code>**，所以查找到这一步就是终点了，如果还是查找失败，那就会返回<code>null</code></p>
<p> <img src="https://upload-images.jianshu.io/upload_images/9240001-235ed6c0cf602e21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原型链"></p>
<p> 这里我们可以来做一个小的逻辑运算题，想象一个函数对象<code>A</code>的<code>prototype</code>是另一个函数对象<code>B</code>构建出的实例，<code>a</code>实例就可以通过<code>__proto__</code>和<code>B</code>的原型连接起来。</p>
<p> 这里我们一定要记住<strong>原型3大定律的第一定律</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span> === son.<span class="property">__proto__</span>);   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p> 在记住这一关系的情况下，<code>A</code>和<code>B</code>的关系就很好理解了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>) &#123;&#125;    <span class="comment">// B.__proto__ === Object.prototype</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();   <span class="comment">// b.__proto__ === B.prototype</span></span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span> = b;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();   <span class="comment">// a.__proto__ === A.prototype === b</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">__proto__</span> === b);   <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">__proto__</span>.<span class="property">__proto__</span> === B.<span class="property"><span class="keyword">prototype</span></span>)  <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">__proto__</span>.<span class="property">__proto__</span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>)  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>



<p>总结一下：</p>
<ul>
<li>JS中所有东西都是对象，函数也是对象，是一种特殊的对象</li>
<li>JS中所有东西都是由<code>Object</code>衍生而来，所有对象原型链的重点都指向<code>Object.prototype</code></li>
<li>对象都有一个隐含的<code>__proto__</code>属性，它指向创建它的构造函数的原型，<code>Object.prototype.__proto__</code>指向<code>null</code></li>
<li>实例的<code>__proto__</code>指向创建它的构造函数的<code>prototype</code>，构造函数的<code>__proto__</code>也指向它的构造函数的<code>prototype</code>，一级一级向上，知道<code>Object.prototype</code></li>
</ul>
<hr>
<h3 id="8-Object-create创建实例"><a href="#8-Object-create创建实例" class="headerlink" title="8. Object.create创建实例"></a>8. <code>Object.create</code>创建实例</h3><p>####<strong>继承</strong></p>
<p>基于上述原型链的关系，子类可以继承父类的属性和方法。</p>
<p>但是继承是一种比较有迷惑性的说法，引用《你不知道的JavaScript》中的话：</p>
<blockquote>
<p>继承意味着复制操作，然而JavaScript默认并不会复制对象的属性，相反，JavaScript只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。</p>
</blockquote>
<p>这里需要注意的地方是，我们在创建实例时，常使用<code>new</code>关键字，这里建议使用<code>Object.create</code>来创建实例，那么这两者的区别是什么呢？</p>
<h4 id="new-创建实例实现原理"><a href="#new-创建实例实现原理" class="headerlink" title="new()创建实例实现原理"></a><strong><code>new()</code>创建实例实现原理</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">obj.<span class="property">__proto__</span> = <span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"><span class="title class_">Father</span>.<span class="title function_">call</span>(obj);</span><br></pre></td></tr></table></figure>

<p><code>new</code>创建实例时经历了这样几步：</p>
<ol>
<li>创建一个空对象<code>obj</code></li>
<li>将空对象的<code>__proto__</code>指向构造函数的原型属性，也就是说<code>obj</code>原型属性上拥有了<code>Father.prototype</code>中的属性和方法</li>
<li>将构造函数中的<code>this</code>指针指向<code>obj</code></li>
</ol>
<h4 id="Object-create-创建实例实现原理"><a href="#Object-create-创建实例实现原理" class="headerlink" title="Object.create()创建实例实现原理"></a><strong><code>Object.create()</code>创建实例实现原理</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property">create</span> = <span class="keyword">function</span>(<span class="params">o</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> F = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它在内部定义了一个对象，并且让<code>F.prototype</code>对象赋值为引进的对象&#x2F;函数<code>o</code>，然后返回新对象。</p>
<h4 id="DRY原则"><a href="#DRY原则" class="headerlink" title="DRY原则"></a><strong>DRY原则</strong></h4><p>正是因为可以从原型链上继承也好，委托也好，父类的属性和方法，因此我们应该多利用这一的特性，将子类	上重复的方法尽量放到父类上，这一可以保持代码的简洁，同时增强可维护性。</p>
<p>​	</p>
<h4 id="继承父类的属性"><a href="#继承父类的属性" class="headerlink" title="继承父类的属性"></a><strong>继承父类的属性</strong></h4><p>当我们先创建父类，并制定父类的<code>prototype</code>后，如果再来创建实例，使用<code>new</code>会产生一些问题，所以建议采用<code>Object.create(supertype.prototype)</code>的方法。</p>
<p>创建后，我们需要将子类的原型设置为父类原型的实例，即<code>Son.prototype = Object.create(Father.prototype)</code>，这样子类的原型就继承了父类原型的所有方法和属性。</p>
<p>但此时继承父类的原型会造成子类同时继承父类的<code>constructor</code>，所以还需要手动地将子类的<code>Son.prototype.constructor = Son</code>。</p>
<h4 id="自己的方法"><a href="#自己的方法" class="headerlink" title="自己的方法"></a><strong>自己的方法</strong></h4><p>在继承父类的属性方法后，子类也可以自己添加方法，或者修改父类已有的方法。方法都是直接在子类的原型上修改。</p>
<hr>
<p>###9. <code>Mixin</code>多继承</p>
<p>用于实现两个不相关的对象共享方法</p>
<hr>
<h3 id="10-私有属性"><a href="#10-私有属性" class="headerlink" title="10. 私有属性"></a>10. <strong>私有属性</strong></h3><p>防止构造函数内部属性被修改，可以在构造函数内部创建变量来保存属性值。</p>
<hr>
<h3 id="11-立即执行函数"><a href="#11-立即执行函数" class="headerlink" title="11. 立即执行函数"></a>11. 立即执行函数</h3><p>立即执行函数的特征是即写即用。</p>
<p>利用立即执行函数可以把相关功能组合成一个模块，模块返回一个对象，对象中可以包含<code>Mixin</code>，这样在调用模块的时候就可以同步调用<code>Mixin</code>.</p>
<p><em>以下是这部分习题的解答，每题的知识点我都有些，有些知识点可能和上面的有些重复.</em></p>
<hr>
<h4 id="习题Introduction-to-the-Object-Oriented-Programming-Challenges"><a href="#习题Introduction-to-the-Object-Oriented-Programming-Challenges" class="headerlink" title="习题Introduction to the Object Oriented Programming Challenges"></a>习题<a target="_blank" rel="noopener" href="https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/object-oriented-programming">Introduction to the Object Oriented Programming Challenges</a></h4><ul>
<li><ol>
<li><a target="_blank" rel="noopener" href="https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/object-oriented-programming/create-a-basic-javascript-object">Create a Basic JavaScript Object</a> <strong>创建JS对象</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Stone&quot;</span>,</span><br><span class="line">  <span class="attr">numLegs</span>: <span class="number">4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><ol start="2">
<li><a target="_blank" rel="noopener" href="https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/object-oriented-programming/use-dot-notation-to-access-the-properties-of-an-object">Use Dot Notation to Access the Properties of an Object</a> <strong>获取对象的属性值</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Spot&quot;</span>,</span><br><span class="line">  <span class="attr">numLegs</span>: <span class="number">4</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Add your code below this line</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog.<span class="property">name</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog.<span class="property">numLegs</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><ol start="3">
<li><a target="_blank" rel="noopener" href="https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/object-oriented-programming/create-a-method-on-an-object">Create a Method on an Object</a> <strong>为对象创建方法</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Spot&quot;</span>,</span><br><span class="line">  <span class="attr">numLegs</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="attr">sayLegs</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;This dog has 4 legs.&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">dog.<span class="title function_">sayLegs</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><a target="_blank" rel="noopener" href="https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/object-oriented-programming/make-code-more-reusable-with-the-this-keyword">Make Code More Reusable with the this Keyword</a> <strong><code>this</code>关键字</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Spot&quot;</span>,</span><br><span class="line">  <span class="attr">numLegs</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="attr">sayLegs</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="keyword">return</span> <span class="string">&quot;This dog has &quot;</span> + <span class="variable language_">this</span>.<span class="property">numLegs</span> + <span class="string">&quot; legs.&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">dog.<span class="title function_">sayLegs</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><ol start="4">
<li><a target="_blank" rel="noopener" href="https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/object-oriented-programming/define-a-constructor-function">Define a Constructor Function</a> <strong>定义构造函数</strong></li>
</ol>
<p><strong><code>Constructors</code>构造函数用来构造新的对象</strong>。对象的属性、行为都被定义在构造函数内。</p>
<p>构造函数的写法规范有：</p>
<ul>
<li>构造函数的<strong>函数名要首字母大写</strong></li>
<li>构造函数<strong>用<code>this</code>来指代将要创建的对象本身</strong></li>
<li>构造函数用来定义对象的属性和行为，而非像普通函数那样返回一个值</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;Stone&quot;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">color</span> = <span class="string">&quot;white&quot;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">numLegs</span> = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><ol start="5">
<li><a target="_blank" rel="noopener" href="https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/object-oriented-programming/use-a-constructor-to-create-objects">Use a Constructor to Create Objects</a> <strong>利用构造函数创建对象</strong></li>
</ol>
<p><strong>用<code>new</code>关键字调用构造函数</strong>。当调用构造函数时，JS会创建一个类的实例（instance）。如果没有使用<code>new</code>，那么构造函数内的<code>this</code>将不会指向新创建的对象。</p>
<p><strong>用<code>new</code>关键字创建的实例将拥有类所有的属性</strong>，这些属性都可以被获取及修改</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;Rupert&quot;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">color</span> = <span class="string">&quot;brown&quot;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">numLegs</span> = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Add your code below this line</span></span><br><span class="line"><span class="keyword">let</span> hound = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><ol start="6">
<li><a target="_blank" rel="noopener" href="https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/object-oriented-programming/extend-constructors-to-receive-arguments">Extend Constructors to Receive Arguments</a> <strong>构造函数传参</strong></li>
</ol>
<p>构造函数可以接受参数来创建不同的实例，这样使得构造函数更为灵活。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params">name, color</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">numLegs</span> = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> terrier = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><ol start="7">
<li><a target="_blank" rel="noopener" href="https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/object-oriented-programming/verify-an-objects-constructor-with-instanceof">Verify an Object’s Constructor with instanceof</a> <strong><code>instanceof</code>验证构造函数的实例</strong></li>
</ol>
<p>构造函数创建的新的对象都叫做它的<strong>实例</strong>，检验一个对象是不是构造函数的实例可以使用<code>instanceof</code>方法，即<code>实例 instanceof 构造函数</code>，结果将返回一个布尔值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">House</span>(<span class="params">numBedrooms</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">numBedrooms</span> = numBedrooms;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add your code below this line</span></span><br><span class="line"><span class="keyword">let</span> myHouse = <span class="keyword">new</span> <span class="title class_">House</span>(<span class="number">12</span>);</span><br><span class="line">myHouse <span class="keyword">instanceof</span> <span class="title class_">House</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><ol start="8">
<li><a target="_blank" rel="noopener" href="https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/object-oriented-programming/understand-own-properties">Understand Own Properties</a> <strong>自有属性</strong></li>
</ol>
<p>如构造函数<code>Bird(name)</code>中的<code>name</code>和<code>numLegs</code>属性都叫函数的<strong>自有属性（own property）</strong>，自有属性直接被定义给实例，即在构造函数中定义，这意味着构造函数<code>Bird</code>的实例都将各自拥有这些属性的副本。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Bird</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">numLegs</span> = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> canary = <span class="keyword">new</span> <span class="title class_">Bird</span>(<span class="string">&quot;Tweety&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> ownProps = [];</span><br><span class="line"><span class="comment">// Add your code below this line</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> property <span class="keyword">in</span> canary) &#123;</span><br><span class="line">  <span class="keyword">if</span>(canary.<span class="title function_">hasOwnProperty</span>(property)) &#123;</span><br><span class="line">    ownProps.<span class="title function_">push</span>(property);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><ol start="9">
<li><a target="_blank" rel="noopener" href="https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/object-oriented-programming/use-prototype-properties-to-reduce-duplicate-code">Use Prototype Properties to Reduce Duplicate Code</a> <strong>原型属性</strong></li>
</ol>
<p>构造函数的实例除了拥有<strong>自有属性</strong>，还拥有<strong>原型属性</strong>。</p>
<p><strong>原型</strong>是所有实例共有的一个对象，这里形容它是“创建对象的‘菜谱’”。在JavaScript中，几乎所有对象都有原型，而且它们的原型是创建它们的构造函数的一部分，如下题中的<code>beagle</code>实例是由<code>Dog</code>构造函数创建的，<code>beagle</code>的原型就是<code>Dog</code>构造函数即<code>Dog.prototype</code>的一部分。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">numLegs</span> = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// Add your code above this line</span></span><br><span class="line"><span class="keyword">let</span> beagle = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Snoopy&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><ol start="10">
<li><a target="_blank" rel="noopener" href="https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/object-oriented-programming/iterate-over-all-properties">Iterate Over All Properties</a> <strong>遍历属性</strong></li>
</ol>
<p>如上所说，对象有两种属性，一种是<strong>自有属性</strong>，是直接创建的实例本身就定义好的，即在构造函数中就定义了的，另一种是<strong>原型属性</strong>，是在原型上定义的。</p>
<p>下面的例子中，在<code>Dog</code>构造函数中就定义了<code>name</code>属性，所以所有的<code>Dog</code>的实例，如<code>beagle</code>都在创建时就拥有<code>name</code>属性，在<code>let beagle = new Dog(&quot;snoopy&quot;);</code>时，<code>beagle</code>就有了<code>name</code>属性及赋予了自己的<code>name</code>属性的值<code>snoopy</code>，所以**<code>name</code>就是所有<code>Dog</code>实例的自有属性<strong>。此外，<code>Dog</code>还在自己的原型上添加了<code>numLegs</code>属性，即<code>Dog.prototype.numLegs = 4;</code>，实例同样拥有在原型上添加的属性，所以<code>beagle.numLegs</code>可以获得<code>4</code>而非<code>undefined</code>。<code>numLegs</code>这种&amp;&amp;直接添加在<code>Dog.prototype</code>上的属性就是原型属性</strong>。</p>
<p>实例同时拥有自有属性和原型属性，但是可以通过<code>instance.hasOwnProperty(property)</code>来判断是哪一类属性。这一题就通过这个方法将<code>beagle</code>的不同属性分别添加到<code>ownProps</code>自有属性数组和<code>prototypeProps</code>原型数组中。如果输出两个数组，得到的结果是<code>ownProps: [&#39;name&#39;] prototypeProps: [&#39;numLegs&#39;]</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">numLegs</span> = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> beagle = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Snoopy&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ownProps = [];</span><br><span class="line"><span class="keyword">let</span> prototypeProps = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add your code below this line </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> property <span class="keyword">in</span> beagle) &#123;</span><br><span class="line">  <span class="keyword">if</span>(beagle.<span class="title function_">hasOwnProperty</span>(property)) &#123;</span><br><span class="line">    ownProps.<span class="title function_">push</span>(property);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    prototypeProps.<span class="title function_">push</span>(property);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><ol start="11">
<li><a target="_blank" rel="noopener" href="https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/object-oriented-programming/understand-the-constructor-property">Understand the Constructor Property</a> <strong>实例的<code>constructor</code>属性</strong></li>
</ol>
<p>实例都拥有一个特殊的属性<code>constructor</code>，这个属性指向创建这些实例的构造函数。如<code>candidate</code>是<code>Dog</code>创建的一个实例，<code>candidate.constructor</code>就是<code>[function: Dog]</code>，但是<code>constructor</code>属性是可以被改写的，所以如果需要验证一个实例的构造函数时，不建议使用下题中的<code>candidate.constructor === Dog</code>这种方法，而是使用前面提到过的<code>candidate instanceof Dog</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Add your code below this line</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">joinDogFraternity</span>(<span class="params">candidate</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(candidate.<span class="property">constructor</span> === <span class="title class_">Dog</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><ol start="12">
<li><a target="_blank" rel="noopener" href="https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/object-oriented-programming/change-the-prototype-to-a-new-object">Change the Prototype to a New Object</a> <strong>让原型指向新的对象</strong></li>
</ol>
<p>上面提到了构造函数有两种属性，自有属性和原型属性，我们可以通过添加原型属性来丰富构造函数的属性，但是如果需要添加的内容较多，代码就会看起来非常臃肿，这时我们可以采取为构造函数的原型指定一个新的对象的方法，在新的对象中包含所有我们需要添加给原型的属性或方法，这样代码会更简洁。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name; </span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="comment">// Add your code below this line</span></span><br><span class="line">  <span class="attr">numLegs</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="attr">eat</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;yummy&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">describe</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;My name is &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><ol start="13">
<li><a target="_blank" rel="noopener" href="https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/object-oriented-programming/remember-to-set-the-constructor-property-when-changing-the-prototype">Remember to Set the Constructor Property when Changing the Prototype</a> <strong>在新对象内设置<code>constructor</code>属性</strong></li>
</ol>
<p>当我们人为地将原型指向一个新的对象时，有一个副作用就是这样会抹去构造函数的<code>constructor</code>属性。这时我们需要手动地添加上定义<code>constructor</code>属性的语句。如下题，在给<code>Dog</code>指定的新原型中加入了<code>constructor: Dog</code>来明确新原型的<code>constructor</code>属性还是<code>Dog</code>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Modify the code below this line</span></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">constructor</span>: <span class="title class_">Dog</span>,</span><br><span class="line">  <span class="attr">numLegs</span>: <span class="number">2</span>, </span><br><span class="line">  <span class="attr">eat</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;nom nom nom&quot;</span>); </span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="attr">describe</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;My name is &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><ol start="14">
<li><a target="_blank" rel="noopener" href="https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/object-oriented-programming/understand-where-an-objects-prototype-comes-from">Understand Where an Object’s Prototype Comes From</a> <strong>原型从何而来</strong></li>
</ol>
<p>对象的原型（<code>__proto__</code>）都继承自它的构造函数的原型属性（<code>prototype</code>）。如<code>beagle</code>是<code>Dog</code>的实例，<code>beagle</code>的原型就是在<code>let beagle = new Dog(&quot;snoopy&quot;)</code>创建它的时候从<code>Dog.prototype</code>继承来的。<code>isPrototypeOf</code>方法可用用于验证对象的原型。<code>Dog.prototype.isPrototypeOf(bealge)</code>就是验证<code>beagle</code>的原型是不是从<code>Dog.prototype</code>继承而来。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> beagle = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Snoopy&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add your code below this line</span></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(beagle);</span><br></pre></td></tr></table></figure>
</li>
<li><ol start="15">
<li><a target="_blank" rel="noopener" href="https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/object-oriented-programming/understand-the-prototype-chain">Understand the Prototype Chain</a> <strong>原型链</strong></li>
</ol>
<p>几乎所有的JavaScript对象（除了null）都有原型<code>prototype</code>，这个<code>prototype</code>本身也是一个对象。因为对象的原型本身也是一个对象，也有它自己的原型<code>prototype</code>，如<code>Dog.prototype</code>的原型<code>prototype</code>就是<code>Object.prototype</code>。</p>
<p>如前面提到的检测对象自有属性的<code>hasOwnProperty(property)</code>方法就是定义在<code>Object.prototype</code>上的方法，<code>Dog.prototype</code>也继承到了这个方法，这种继承关系就是<strong>原型链</strong>。在这个原型链中，<code>Dog</code>是<code>beagle</code>的父类（**<code>supertype</code><strong>），<code>beagle</code>是<code>Dog</code>的子类（</strong><code>subtype</code>**），<code>Object</code>既是<code>Dog</code>的父类，也是<code>beagle</code>的父类。</p>
<p><code>Object</code>是JS中一切对象的父类，因此，任何对象都可以使用<code>hasOwnProperty</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> beagle = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Snoopy&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(beagle);  <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Fix the code below so that it evaluates to true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(<span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br></pre></td></tr></table></figure>
</li>
<li><ol start="16">
<li><a target="_blank" rel="noopener" href="https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/object-oriented-programming/use-inheritance-so-you-dont-repeat-yourself">Use Inheritance So You Don’t Repeat Yourself</a> <strong><code>DRY</code>原则</strong></li>
</ol>
<p>编程的一个原则叫做<code>Don&#39;t Repeat Yourself(DRY)</code>，意思是不要重复写你写过的内容，因为重复的代码会很难维护，一旦要修改某个内容，就需要修改多处，这样会增加工作量，而且也更容易出错。</p>
<p>这里举了一个例子，有<code>Bird</code>和<code>Dog</code>两个构造函数，它们都有<code>describe()</code>这个方法，内容是重复的，想要遵从<code>DRY</code>原则避免重复，一个方法是为这两个构造函数增加一个父类<code>Animal</code>，并为父类定义<code>describe</code>函数，这样<code>Bird</code>和<code>Dog</code>都能从<code>Animal</code>继承<code>describe</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Cat</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">constructor</span>: <span class="title class_">Animal</span>, </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Bear</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Bear</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">constructor</span>: <span class="title class_">Animal</span>, </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">constructor</span>: <span class="title class_">Animal</span>,</span><br><span class="line">  <span class="attr">eat</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;nom nom nom&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><ol start="17">
<li><a target="_blank" rel="noopener" href="https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/object-oriented-programming/inherit-behaviors-from-a-supertype">Inherit Behaviors from a Supertype</a> <strong>继承</strong></li>
</ol>
<p>像上一题中，我们先创建父类，然后让子类使用父类的方法的行为叫做<strong>继承</strong>。这一题的知识点在于如何创建父类的实例。通常我们会使用<code>new</code>关键字来创建实例，但是这样在继承父类的属性和方法时会有一些问题，所以更建议使用<code>Object.create(supertype.prototype)</code>。</p>
<p><code>Object.create(obj)</code>方法会创建一个新的对象，然后将参数<code>obj</code>作为新创建的对象的原型<code>prototype</code>，这样就能让新创建的对象实例拥有原型的方法和属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">constructor</span>: <span class="title class_">Animal</span>, </span><br><span class="line">  <span class="attr">eat</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;nom nom nom&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add your code below this line</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> duck = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// Change this line</span></span><br><span class="line"><span class="keyword">let</span> beagle = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// Change this line</span></span><br><span class="line"></span><br><span class="line">duck.<span class="title function_">eat</span>(); <span class="comment">// Should print &quot;nom nom nom&quot;</span></span><br><span class="line">beagle.<span class="title function_">eat</span>(); <span class="comment">// Should print &quot;nom nom nom&quot; </span></span><br></pre></td></tr></table></figure>
</li>
<li><ol start="18">
<li><a target="_blank" rel="noopener" href="https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/object-oriented-programming/set-the-childs-prototype-to-an-instance-of-the-parent">Set the Child’s Prototype to an Instance of the Parent</a> <strong>设置子类的原型</strong></li>
</ol>
<p>创建实例之后，我们需要将子类的原型设置为父类原型的实例。如我们将<code>Dog</code>的原型设置为<code>Animal</code>的原型的实例：<code>Dog.prototype = Object.create(Animal.prototype)</code>，这样<code>Dog</code>的原型就继承了<code>Animal</code>原型的所有方法和属性，<code>Dog</code>的实例如<code>beagle</code>就能继承<code>Animal</code>的方法如<code>eat</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">constructor</span>: <span class="title class_">Animal</span>,</span><br><span class="line">  <span class="attr">eat</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;nom nom nom&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add your code below this line</span></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> beagle = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">beagle.<span class="title function_">eat</span>();  <span class="comment">// Should print &quot;nom nom nom&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><ol start="19">
<li><a target="_blank" rel="noopener" href="https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/object-oriented-programming/reset-an-inherited-constructor-property">Reset an Inherited Constructor Property</a> <strong>重设子类的<code>constructor</code>属性</strong></li>
</ol>
<p>当一个对象继承另一个对象的原型<code>prototype</code>时，它也继承了父类的<code>constructor</code>属性，如<code>Bird</code>的原型继承了<code>Animal</code>的原型，这时<code>Bird</code>的实例如<code>duck</code>的<code>constructor</code>属性就会指向<code>Animal</code>而不是<code>Bird</code>。但我们仍需要<code>duck</code>的<code>constructor</code>指向<code>Bird</code>，这时就需要我们手动将<code>Bird</code>的原型的<code>constructor</code>属性<code>Bird.prototype.constructor</code>指向回<code>Bird</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Bird</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Bird</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add your code below this line</span></span><br><span class="line"><span class="title class_">Bird</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Bird</span>;</span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Dog</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> duck = <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line"><span class="keyword">let</span> beagle = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><ol start="20">
<li><a target="_blank" rel="noopener" href="https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/object-oriented-programming/add-methods-after-inheritance">Add Methods After Inheritance</a> <strong>构造函数添加方法</strong></li>
</ol>
<p>当构造函数继承父类的原型时，除了拥有父类的方法，还可以添加自己的方法。</p>
<p>通过添加方法到子类的原型上，我们可以让子类拥有自己独特的方法，如<code>Bird</code>继承了<code>Animal</code>的方法，但通过<code>Bird.prototype.fly = function() &#123;...&#125;</code>可以给<code>Bird</code>添加<code>fly()</code>方法。</p>
<p>此时，<code>Bird</code>的实例就拥有了<code>eat()</code>和<code>fly()</code>两个方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eat</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;nom nom nom&quot;</span>); &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add your code below this line</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Dog</span>;</span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bark</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Woof&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add your code above this line</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> beagle = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"></span><br><span class="line">beagle.<span class="title function_">eat</span>(); <span class="comment">// Should print &quot;nom nom nom&quot;</span></span><br><span class="line">beagle.<span class="title function_">bark</span>(); <span class="comment">// Should print &quot;Woof!&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><ol start="21">
<li><a target="_blank" rel="noopener" href="https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/object-oriented-programming/override-inherited-methods">Override Inherited Methods</a> <strong>修改父类方法</strong></li>
</ol>
<p>前面我们提到了，子类可以通过复制父类的原型来继承父类的方法，也可以通过给自己的原型绑定方法来添加自己的方法。同样的，子类也可以通过给自己的原型绑定父类的方法来修改父类的方法。</p>
<p>当我们使用<code>new</code>关键词来创建实例，并且调用构造函数的方法时，如<code>let duck = new Bird();  duck.eat()</code>，JavaScript对<code>duck&#39;s prototype</code>机制是这样的：</p>
<ol>
<li>先查看<code>duck</code>的原型属性是否有<code>eat()</code>方法，如果没有</li>
<li>查看<code>Bird</code>的原型属性是否有<code>eat()</code>方法，有，那么执行并停止搜索</li>
<li><code>Animal</code>也定义了<code>eat()</code>方法，但是因为JavaScript已经停止查找，所以无法达到这一层</li>
<li><code>Object</code>层，JavaScript已经停止查找，无法到达这一层</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Bird</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Bird</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">fly</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&quot;I am flying!&quot;</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Penguin</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"><span class="title class_">Penguin</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Bird</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Penguin</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Penguin</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add your code below this line</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Penguin</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">fly</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&quot;Alas, this is a flightless bird.&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add your code above this line</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> penguin = <span class="keyword">new</span> <span class="title class_">Penguin</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(penguin.<span class="title function_">fly</span>());</span><br></pre></td></tr></table></figure>
</li>
<li><ol start="22">
<li><a target="_blank" rel="noopener" href="https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/object-oriented-programming/use-a-mixin-to-add-common-behavior-between-unrelated-objects">Use a Mixin to Add Common Behavior Between Unrelated Objects</a> <strong><code>Mixin</code>实现多继承</strong></li>
</ol>
<p>继承能够将一个对象的方法传递给另一个对象，但是有时两个并不相关的对象也会拥有一样的方法，比如<code>Bird</code>和<code>Airplane</code>，这时无法用继承来共享方法，这时可以用<code>mixins</code>让不同的对象共享相同的方法。</p>
<p>它的写法是：</p>
<ol>
<li>创建一个<code>mixin</code>，这一题创建的是一个翱翔的<code>glideMixin</code>，它的参数是<code>obj</code>，即会使用这个<code>mixin</code>的对象</li>
<li>在<code>mixin</code>内创建<code>obj</code>的方法</li>
<li>调用<code>mixin</code>，将需要共享方法的对象以参数的形式传给<code>mixin</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bird = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Donald&quot;</span>,</span><br><span class="line">  <span class="attr">numLegs</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> boat = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Warrior&quot;</span>,</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;race-boat&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add your code below this line</span></span><br><span class="line"><span class="keyword">let</span> glideMixin = <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    obj.<span class="property">glide</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;glide&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">glideMixin</span>(bird);</span><br><span class="line"><span class="title function_">glideMixin</span>(boat);</span><br></pre></td></tr></table></figure>
</li>
<li><ol start="23">
<li><a target="_blank" rel="noopener" href="https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/object-oriented-programming/use-closure-to-protect-properties-within-an-object-from-being-modified-externally">Use Closure to Protect Properties Within an Object from Being Modified Externally</a> <strong>防止属性被更改</strong></li>
</ol>
<p>在前面的习题中，实例的<code>name</code>属性是公开属性，即可以在定义<code>bird</code>实例的语句外部获取和修改属性。对于某些属性，如密码或者银行账户来说，这样实在太不安全了。</p>
<p>最简单的创建私密属性的方法是在构造函数内部创建一个变量，这样能够将变量的作用域由全局转变为函数级作用域，变量只能在构造函数内部被获取和修改。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Bird</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> weight = <span class="number">15</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getWeight</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> weight;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><ol start="24">
<li><a target="_blank" rel="noopener" href="https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/object-oriented-programming/understand-the-immediately-invoked-function-expression-iife">Understand the Immediately Invoked Function Expression (IIFE)</a> <strong>立即执行函数</strong></li>
</ol>
<p>立即执行函数（IIFE)在JavaScript中是非常常见的一种形式，它的特征包括：</p>
<ul>
<li><p>没有函数名，不用变量存储</p>
<p>函数被<code>()</code>包围，且函数末尾有一对括号<code>()</code>表明函数在声明之后会被立即执行</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;A cozy nest is ready&quot;</span>);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
</li>
<li><ol start="25">
<li><a target="_blank" rel="noopener" href="https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/object-oriented-programming/use-an-iife-to-create-a-module">Use an IIFE to Create a Module</a></li>
</ol>
<p>立即执行函数常被用来将相关的功能组合成一个对象或模块。比如我们可以创建一个对象模块，让它是立即执行函数，在函数内部返回一个或多个<code>mixin</code>，这样我们在调用模块的时候可以同步调用<code>mixin</code>，如下题中，我们可以<code>funModule.isCuteMixin(cat);    cat.isCute</code>，使代码更简洁。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> funModule = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">isCuteMixin</span>: <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">      obj.<span class="property">isCute</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">singMixin</span>: <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">      obj.<span class="property">sing</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Singing to an awesome tune&quot;</span>);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/freecodecamp/" rel="tag"># freecodecamp</a>
              <a href="/tags/OOP/" rel="tag"># OOP</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2018/07/06/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/" rel="prev" title="ES6学习笔记之解构赋值">
                  <i class="fa fa-angle-left"></i> ES6学习笔记之解构赋值
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2018/07/10/%E7%AE%97%E6%B3%95%E4%B8%AD%E7%BA%A7/" rel="next" title="算法中级">
                  算法中级 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2018 – 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class=""></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Xu Quan</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"IcWbltr2BErnzeh08rQq5Awt-MdYXbMMI","app_key":"MBmkp7Em4UZXFeXVz4D0XIL2","server_url":null,"security":true}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"xuquan","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
